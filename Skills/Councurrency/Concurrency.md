---
title: 并发
date: 2019-01-16 00:00:04
tags: 
categories: 
---

**目录 start**
 
1. [并发编程](#并发编程)

**目录 end**|_2019-01-16 00:00_| [码云](https://gitee.com/gin9) | [CSDN](http://blog.csdn.net/kcp606) | [OSChina](https://my.oschina.net/kcp1104) | [cnblogs](http://www.cnblogs.com/kuangcp)
****************************************
# 并发编程
> 在抽象角度考虑并发

- [并发编程网](http://ifeve.com/)

> [参考: 解道 并发编程](https://www.jdon.com/concurrency.html)

> 在过去的30年里，计算机的性能是在摩尔定律的推动下，从现在开始，这将由Amdahl定律决定。编写代码，有效地利用多个处理器可以是非常具有挑战性的。" -- Doron Rajwan

进行多核多服务器时代，并行并发模式更是对程序员的挑战，现在所谓的Thread Programmer世界上也是为数不多，因为线程表面上好像很容易，但在实际应用中真正应付大负荷运算时，原来的线程设计方案漏洞百出。

并发concurrency属于问题域(problem domain), 并行parallelism属于( solution domain)。
并行和并发的区别在于有无状态，并行计算适合无状态应用，而并发解决的是有状态的高性能； 有状态要着力解决并发计算，无状态要着力并行计算

并发主要是要解决资源争夺，并发一般发生在数据聚合的地方，只要有聚合，就有争夺发生，传统解决争夺的方式采取线程锁机制，这是强行对CPU管理线程人为干预，线程唤醒成本高，新的无锁并发策略来源于Java的NIO或Node.js，通过队列+单线程操作资源的方式巧妙避免了多线程，由于只有一个线程，在多核情况下增加了并行计算的机会。

并发模型分两种，并发基础线程和并发组件模型，并发组件模型让使用者接触不到基础线程概念，是一种简化。作为一个高级集成架构师，应该在程序范式的高级层次定义并发，基于组件级别的并发，并且尽可能地避免涉及线程概念以及线程池等底层概念。

实现并发的途径有两种，基于线程和基于事件 [基于线程与基于事件的并发编程之争](https://www.jdon.com/46921)

